# 1단계 기능 요구사항

- 자동차는 **이름**을 가지고 있다.
- 자동차는 **움직일 수** 있다.
- 0에서 9 사이의 **random** 값을 구한 후, random 값이 4 이상일 경우 전진하고, 3 이하일 경우 **멈춘다**.

----------

- 이름을 inputview로 받기
- 랜덤 값 구해서 메서드 -> 0에서 9 사이의 random 값 구하기
- 움직임 결정 메서드 -> 랜덤 메서드 값으로 결정 if문 4이상이면 전진, 아니면 움직이지 않음
- 랜덤 값 구하는 메서드 필드에 선언 or 인터페이스(or 추상클래스)

- 인터페이스란?
  클래스들의 기본적이고 공통적인 틀을 제공해 서로 다른 클래스들을 하나의 자료형으로 묶어주는 역할의 일종의 추상 클래스.
  클래스들을 작성할 때 클래스들의 기본적인 틀을 제공하며, 인터페이스는 클래스들이 인터페이스의 추상 메서드를 오버라이드하여 각자 다른 방법으로 구현하게 하여 클래스들을 하나로 묶어준다.
  상수와, 추상 메서드, 디폴트 메서드, 정적 메서드 선언할 수 있다. 또 인터페이스로 하위 클래스의 인스턴스를 인터페이스의 참조변수로 참조하는 것이 가능하다.
- 인터페이스를 쓰는 이유는?
  인터페이스는 다른 클래스를 작성할 때 일종의 틀을 제공해 상위 클래스의 동일한 메세지로 하위 클래스들이 메세지를 활용하여 서로 다른 동작을 할 수 있게 한다.
  다양한 구현체를 동일한 방식, 동일한 인터페이스로 처리할 수 있게 한다. Override로 하나의 인터페이스 메서드를 사용해도 하위 클래스들에서 서로 다른 여러 동작을 수행할 수 있고, 하나의 인터페이스를 통해
  여러 객체를 동작할 수 있다.
  결국 인터페이스를 사용하여 이와 같은 다형성을 활용하여 코드의 수정을 줄이고, 유지보수성을 높일 수 있다.
- mission1에서 인터페이스를 사용하는 이유
  인터페이스를 사용해 랜덤값을 생성하는 메서드만의 구현에 의존하지 않고 가장 상위에서 추상적이고 공통적인 틀을 제공해 추후에 다른 방식의 난수를 생성하는 하위 클래스들을 추가, 교체할 때 코드를
  관리하고 수정하기 편리하다.
  또 인터페이스를 적용하여 랜덤 수를 반환하도록 추상적인 형태로 만들고 하위 클래스에서 오버라이딩하여 일정 범위에서 랜덤 수를 뽑는 메서드를 구현하여 예측불가능한 수를 반환하는 메서드를 커스터마이징하여
  원하는 고정된 값을 반환하도록 하여 forwardOrStop메서드와 랜덤 수 반환 메서드에 대한 검증을 진행할 수 있다.

--------

# 2단계 기능 요구사항

- **n대의 자동차**가 경주에 참여할 수 있다.
- 주어진 횟수 동안 n대의 자동차는 **전진**하거나 **멈출** 수 있다.
- 0에서 9 사이의 **random** 값을 구한 후, random 값이 **4 이상**일 경우 **전진**하고, **3 이하**일 경우 **멈춘다**.
- 자동차 경주 게임이 끝나면 **누가 우승했는지**를 구할 수 있다.
- **우승자**는 한 명 이상일 수 있다.

## 새로운 프로그래밍 요구사항
- **우승자를 구하는 기능**이 의도대로 동작하는지 테스트한다.

## 기존 프로그래밍 요구사항
- **메인 메서드**는 만들지 않는다.
- **자바 코드 컨벤션**을 준수하며 프로그래밍한다.
- 기본적으로 **Java Style Guide**를 원칙으로 한다.
- **Indent(인덴트, 들여쓰기) depth**를 2를 넘지 않도록 구현하며, **1까지만** 허용한다.
  - 예시: `while`문 안에 `if`문이 있으면 들여쓰기는 2이다.
  - 힌트: 인덴트 depth를 줄이기 위해 **함수(또는 메서드)**를 분리한다.
- **3항 연산자**를 사용하지 않는다.
- **else** 예약어를 사용하지 않는다.
  - **switch/case**도 허용하지 않는다.
  - 힌트: **if문**에서 값을 반환하는 방식으로 구현하면 **else** 예약어를 사용하지 않아도 된다.
- 함수(또는 메서드)의 **길이**가 15라인을 넘지 않도록 구현한다.
- 함수(또는 메서드)가 **한 가지 일**만 잘 하도록 구현한다.

---

##
- 원시값 포장을 이용하여 n개의 차가 각자 기능을 수행하는 레이싱을 진행하려고 한다.
- 원시값 포장이란??
- 원시값이란 실제 데이터 값을 말하고 원시 타입은 그러한 실제 데이터 값을 저장하는 타입으로 int, boolean, char, float 등이 있다.
- 변수를 선언하는 방법엔 원시 타입의 변수를 선언하는 방법과 원시 타입의 변수를 객체로 포장한 변수를 선언하는 방법이 있다.
~~~~
int age = 20;
Age age = new Age(20);
~~~~
- 원시값 포장이란 첫번째 방법처럼, 원시유형의 값을 이용해 의미를 나타내지 않고, 두번째 방법처럼 의미 있는 '객체'로 포장하는 개념
- 그렇다면 왜 원시값 포장을 해야 할까??
- 한 클래스는 한 가지 역할만 하는 것이 좋다. 때문에 클래스의 멤버변수들에 대한 각 상태관리를 각자 하게 하여 책임을 명확하게 한다. 자신의 상태를 객체 스스로 관리하게 하는 것이다.
- 또 값에 의미를 부여할 수 있기 때문에 개발 과정에서 일관된 타입을 전달할 수 있어 유지보수에 용이해진다.
##
- 이번 단계에서 원시값 포장을 한다면 Car 객체에 부여되어있는 책임을 분할함으로써 적절한 객체에게 적절한 책임을 할당하는것
- Car는 경주에서 속성을 갖는다. - 이름과 현재 움직임 상태.
- 현재 상태(state) Integer이고, 어떤 조건이 충족되면 차의 현재 움직임 상태를 1 더한다. 아니라면 움직이지 않는다.
- 그 조건은 랜덤수를 넘겨 받았을 때 4이상이느냐?
- CarName은 차의 이름을 포장하여 Car에게 차 이름을 관리하는 책임을 덜고 차 이름 자신에 대한 관리를 자신이 하게 하여 책임을 명확하게 한다.
