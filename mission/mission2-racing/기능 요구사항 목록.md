# 1단계 기능 요구사항

- 자동차는 **이름**을 가지고 있다.
- 자동차는 **움직일 수** 있다.
- 0에서 9 사이의 **random** 값을 구한 후, random 값이 4 이상일 경우 전진하고, 3 이하일 경우 **멈춘다**.

---

- 이름을 inputview로 받기
- 랜덤 값 구해서 메서드 -> 0에서 9 사이의 random 값 구하기
- 움직임 결정 메서드 -> 랜덤 메서드 값으로 결정 if문 4이상이면 전진, 아니면 움직이지 않음
- 랜덤 값 구하는 메서드 필드에 선언 or 인터페이스(or 추상클래스)

- 인터페이스란?
  클래스들의 기본적이고 공통적인 틀을 제공해 서로 다른 클래스들을 하나의 자료형으로 묶어주는 역할의 일종의 추상 클래스.
  클래스들을 작성할 때 클래스들의 기본적인 틀을 제공하며, 인터페이스는 클래스들이 인터페이스의 추상 메서드를 오버라이드하여 각자 다른 방법으로 구현하게 하여 클래스들을 하나로 묶어준다.
  상수와, 추상 메서드, 디폴트 메서드, 정적 메서드 선언할 수 있다. 또 인터페이스로 하위 클래스의 인스턴스를 인터페이스의 참조변수로 참조하는 것이 가능하다.
- 인터페이스를 쓰는 이유는?
  인터페이스는 다른 클래스를 작성할 때 일종의 틀을 제공해 상위 클래스의 동일한 메세지로 하위 클래스들이 메세지를 활용하여 서로 다른 동작을 할 수 있게 한다.
  다양한 구현체를 동일한 방식, 동일한 인터페이스로 처리할 수 있게 한다. Override로 하나의 인터페이스 메서드를 사용해도 하위 클래스들에서 서로 다른 여러 동작을 수행할 수 있고, 하나의 인터페이스를 통해
  여러 객체를 동작할 수 있다.
  결국 인터페이스를 사용하여 이와 같은 다형성을 활용하여 코드의 수정을 줄이고, 유지보수성을 높일 수 있다.
- mission1에서 인터페이스를 사용하는 이유
  인터페이스를 사용해 랜덤값을 생성하는 메서드만의 구현에 의존하지 않고 가장 상위에서 추상적이고 공통적인 틀을 제공해 추후에 다른 방식의 난수를 생성하는 하위 클래스들을 추가, 교체할 때 코드를
  관리하고 수정하기 편리하다.
  또 인터페이스를 적용하여 랜덤 수를 반환하도록 추상적인 형태로 만들고 하위 클래스에서 오버라이딩하여 일정 범위에서 랜덤 수를 뽑는 메서드를 구현하여 예측불가능한 수를 반환하는 메서드를 커스터마이징하여
  원하는 고정된 값을 반환하도록 하여 forwardOrStop메서드와 랜덤 수 반환 메서드에 대한 검증을 진행할 수 있다.

---

# 2단계 기능 요구사항

- **n대의 자동차**가 경주에 참여할 수 있다.
- 주어진 횟수 동안 n대의 자동차는 **전진**하거나 **멈출** 수 있다.
- 0에서 9 사이의 **random** 값을 구한 후, random 값이 **4 이상**일 경우 **전진**하고, **3 이하**일 경우 **멈춘다**.
- 자동차 경주 게임이 끝나면 **누가 우승했는지**를 구할 수 있다.
- **우승자**는 한 명 이상일 수 있다.

## 새로운 프로그래밍 요구사항
- **우승자를 구하는 기능**이 의도대로 동작하는지 테스트한다.

## 기존 프로그래밍 요구사항
- **메인 메서드**는 만들지 않는다.
- **자바 코드 컨벤션**을 준수하며 프로그래밍한다.
- 기본적으로 **Java Style Guide**를 원칙으로 한다.
- **Indent(인덴트, 들여쓰기) depth**를 2를 넘지 않도록 구현하며, **1까지만** 허용한다.
  - 예시: `while`문 안에 `if`문이 있으면 들여쓰기는 2이다.
  - 힌트: 인덴트 depth를 줄이기 위해 **함수(또는 메서드)**를 분리한다.
- **3항 연산자**를 사용하지 않는다.
- **else** 예약어를 사용하지 않는다.
  - **switch/case**도 허용하지 않는다.
  - 힌트: **if문**에서 값을 반환하는 방식으로 구현하면 **else** 예약어를 사용하지 않아도 된다.
- 함수(또는 메서드)의 **길이**가 15라인을 넘지 않도록 구현한다.
- 함수(또는 메서드)가 **한 가지 일**만 잘 하도록 구현한다.

---

##
- 원시값 포장을 이용하여 n개의 차가 각자 기능을 수행하는 레이싱을 진행하려고 한다.
- 원시값 포장이란??
- 원시값이란 실제 데이터 값을 말하고 원시 타입은 그러한 실제 데이터 값을 저장하는 타입으로 int, boolean, char, float 등이 있다.
- 변수를 선언하는 방법엔 원시 타입의 변수를 선언하는 방법과 원시 타입의 변수를 객체로 포장한 변수를 선언하는 방법이 있다.
~~~~
int age = 20;
Age age = new Age(20);
~~~~
- 원시값 포장이란 첫번째 방법처럼, 원시유형의 값을 이용해 의미를 나타내지 않고, 두번째 방법처럼 의미 있는 '객체'로 포장하는 개념
- 그렇다면 왜 원시값 포장을 해야 할까??
- 한 클래스는 한 가지 역할만 하는 것이 좋다. 때문에 클래스의 멤버변수들에 대한 각 상태관리를 각자 하게 하여 책임을 명확하게 한다. 자신의 상태를 객체 스스로 관리하게 하는 것이다.
- 또 값에 의미를 부여할 수 있기 때문에 개발 과정에서 일관된 타입을 전달할 수 있어 유지보수에 용이해진다.
##

step2에서는 n대의 자동차가 경주에 참여할 수 있고 주어진 횟수 동안 n대의 자동차는 전진하거나 멈출 수 있다. 경주가 끝나면 누가 우승했는지를 구할 수 있다. 우승자는 한 대 이상일 수 있다. 
레이싱 프로그램에서 필요한 것은 차와 경주하는 시스템이다. 
몇대의 차를 가지고 경주를 하든 차들은 각자 이름과 위치를 가진다. 차는 운전(전진하거나 멈춤)할 수 있다. 
레이싱을 구성하는 차는 랜덤수를 뽑아 4이상의 수가 나오면 전진하고, 그렇지 않으면 정지한다.

이름과 위치는 상태라고 할 수 있고, 운전은 행동이라고 볼 수 있다. 객체의 행동이 상태를 결정한다. 여기서 운전이 위치를 결정한다. 
우선 어떤 행동이 필요할지 결정하고 그에 맞는 상태를 결정해야 한다. 
차는 조건에 따라 움직이고 멈추는 행동이 필요하다. 여기서 조건은 랜덤 수가 4이상이냐는 것이다. 랜덤수를 뽑는 것이 그 행동이다. 충족하는지 아닌지가 상태이다. 랜덤수를 뽑는 행동이 충족하는지 아닌지 상태를 결정한다. 
그 상태에 따라 움직이거나 멈추는 행동이 차의 위치를 결정한다. 차의 전 위치와 현재 위치를 알면 행동이 무엇이었는지 알 수 있으므로 행동이 중요한 것이다.

하지만 이름과 위치라는 상태에 대한 책임이 불명확하고 자율적이지 않게 차에 종속되어있다.
이름 그 자체로 자신이 스스로 관리하게 하고, 상태 그 자체로 자신이 스스로 관리하게 할 수 있다.
운전이라는 행동에 따라 상태가 결정된다. 운전은 차가 할 수 있는 행동 중 하나라고 생각을 한다.
그러므로 운전과 위치는 Car에 책임을 부여하고, 이름은 원시값을 포장하여 관리와 캡슐화가 용이하도록한다. - Car, CarName에서 관리하자

- 각 차는 차의 이름과 위치를 가진다.
- 랜덤수에 따라 차를 전진시키거나 정지한다.

- CarName은 차의 이름값을 받아 저장한다.

또한 여러 대의 차를 관리해야 한다면 이 차들을 한꺼번에 관리하는 것도 필요해보인다. - Cars에서 관리하자
그렇지 않으면 여러대의 자동차(객체)가 들어올때마다 각각 이름을 받고 움직이고 상태를 변경하고, 또 이름을 받고 움직이고 상태를 변경하고 그렇게 한다면 너무나 비효율적이다.
차들을 한데 묶어, 한꺼번에 움직이고, 한꺼번에 이름을 관리하며, 한꺼번에 반환하고, 추가되는 기능이 있다면 한꺼번에 적용시킬 수 있다.
차들을 한번에 움직이게 하여 경주하는 것을 Cars에서 관리하도록 한다면 Cars에서 가져야 하는 것은 다음과 같다.

- Cars는 차들의 명단을 받아 저장한다.
- 여러대의 차들을 각자 랜덤수를 받아 정해진 횟수동안 운전을 동시에 하게 해야 한다.
- 우승자를 찾기 위해서는 차의 위치 중 누가 가장 앞에 있는지를 알아내야 한다.
- 또 그 값과 위치가 같은 차를 찾아 우승자를 찾아낼 수 있다. 
- 우승자가 복수일수도 있다.
- 우승자를 최종적으로 반환할 수 있어야 한다. 
- 우승자를 찾기 위해 차들의 위치 중 최대값을 찾아야 한다. 
- for문을 사용하여 초기 max값을 0으로 설정하고, 0보다 큰 값이 있다면 그 값을 갱신하는 식으로 최대값을 찾을 수 있다. for문으로 최대값보다 큰 지?를 찾는 if문을 차의 수만큼 반복해야한다.
- 때문에 들여쓰기 depth가 2가 넘어 가독성이 해쳐져 메서드를 분리해야 했다. 하지만 최대값을 갱신하는 메서드를 차의 수만큼 반복하는 메서드가 참조하게 되고, 그 메서드를 우승자를 찾는 메서드가 참조하게 되어 의존성이 생기게 되었다. 
- 최대값을 찾기 위한 새로운 방법으로 최대값을 찾기 위해 stream으로 Cars 내부의 각 Car의 위치를 내부에서 순차적으로 반복하여 찾을 수 있다. .max()으로 그 위치의 최대값을 찾을 수 있다.

이번 스텝에서는 입력으로부터 차를 받지는 않는다고 생각하여 Controller에서 직접 차를 만들어 레이싱 게임을 구현하였다. 
하지만 직접 만드는 차가 아닌 객체끼리 넘겨받은 여러 대의 차들로 레이싱을 진행하는 것이 더 객체지향적이라고 생각하여 입력에서 받은 차들로 레이싱을 진행하게 하였다.

또, Cars에서 너무 많은 역할과 책임이 부여되어있다.
그래서 Cars는 차들의 데이터를 전달해주기만 하는 역할을 부여하기로 하고, 실제로 레이싱을 진행시키는 것은 Racing에, 들어온 차 명단을 바탕으로 차를 등록시키는 것은 Registration에 책임을 부여하기로 하였다.

---

# 🚀 3단계 - 게임 실행

## 기능 요구사항
- 주어진 횟수 동안 **n대의 자동차**는 전진하거나 멈출 수 있다.
- 각 자동차에 **이름**을 부여할 수 있으며, 전진하는 자동차를 출력할 때 **자동차 이름**을 함께 출력한다.
- 자동차 이름은 **쉼표(,)**를 기준으로 구분하며, 이름은 **5자 이하**만 가능하다.
- 사용자는 **이동할 횟수**를 입력할 수 있어야 한다.
- 전진하는 조건은 **0에서 9 사이의 random 값**을 구한 후, random 값이 **4 이상**일 경우 **전진**하고, **3 이하**일 경우 **멈춘다**.
- 자동차 경주 게임이 끝난 후, **누가 우승했는지**를 알려준다. 우승자는 한 명 이상일 수 있다.

## 실행 결과
* 다음은 위 요구사항에 따라 3대의 자동차가 5번 움직였을 때의 결과 예시이다.


~~~
경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분).
neo,brie,brown
시도할 회수는 몇회인가요?
5

실행 결과
neo : -
brie : -
brown : -

neo : --
brie : -
brown : --

neo : ---
brie : --
brown : ---

neo : ----
brie : ---
brown : ----

neo : -----
brie : ----
brown : -----

neo : -----
brie : ----
brown : -----

neo, brown가 최종 우승했습니다.
~~~

## 새로운 프로그래밍 요구사항
- **메인 메서드**를 추가하여 실행 가능한 애플리케이션으로 만든다.

---

step3에서는 레이싱을 진행시킬 lap 수와 경주할 자동차들의 이름을 입력하고, 매 lap마다 각 차의 경주 진행 상황을 이름과 함께 보여주어야한다.
차들의 이름을 입력으로부터 받고 구분하여 리스트에 담아 경주를 시키는데, 한 lap을 돌고 각 차의 진행을 보여주고 난 다음에 다음 lab 진행한다.

Racing에서 전달받은 랩 수만큼 한꺼번에 경주를 시키지 않고, 
한 랩 동안 경주를 시키고(Racing) 진행을 보여주는 것(Outputview)을 받은 횟수만큼 반복시키는 것을 Controller에서 진행하기로 하였다.

결과 예시처럼 각 lap마다 진행상황을 더 잘 보여주기 위해 각 차의 position을 숫자가 아닌 "-"로 바꾸고 최대거리와 우승자를 찾는 것에서 "-"의 길이를 이용하여 구한다.
